<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>图片水印工具</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f4;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 900px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .controls, .preview {
            flex: 1;
            min-width: 300px;
        }
        .controls h2, .preview h2 { /* General h2 styling */
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
            margin-top: 0; /* Adjusted for tab content */
            margin-bottom: 20px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        .form-group input[type="file"],
        .form-group input[type="text"],
        .form-group input[type="number"],
        .form-group input[type="color"],
        .form-group select,
        .form-group textarea {
            width: calc(100% - 12px);
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        .form-group input[type="range"] {
            width: 100%;
            padding: 0;
        }
        .preview-area {
            border: 1px solid #ddd;
            min-height: 300px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #e9e9e9;
            overflow: hidden;
            position: relative;
        }
        .preview-area canvas {
            max-width: 100%;
            max-height: 100%;
            display: block;
        }
        .download-btn {
            background-color: #28a745;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 20px;
            width: 100%;
        }
        .download-btn:hover {
            background-color: #218838;
        }

        /* Tab Styles */
        .tab-nav {
            display: flex;
            border-bottom: 2px solid #eee;
            margin-bottom: 20px;
        }
        .tab-nav-button {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            background-color: transparent;
            font-size: 16px;
            color: #555;
            border-bottom: 2px solid transparent; /* For active state */
            margin-bottom: -2px; /* Align with container border */
        }
        .tab-nav-button.active {
            color: #007bff;
            border-bottom-color: #007bff;
            font-weight: bold;
        }
        .tab-content {
            display: none; /* Hidden by default */
        }
        .tab-content.active {
            display: block; /* Shown when active */
        }


        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <h1>图片水印工具</h1>
    <div class="container">
        <div class="controls">
            <div class="form-group">
                <label for="imageUpload">选择图片 (可多选):</label>
                <input type="file" id="imageUpload" accept="image/*" multiple>
            </div>

            <div class="tab-nav">
                <button class="tab-nav-button active" data-tab="textWatermarkSettingsTab">文字水印</button>
                <button class="tab-nav-button" data-tab="imageWatermarkSettingsTab">图片水印</button>
            </div>

            <div id="textWatermarkSettingsTab" class="tab-content active">
                <h2>文字水印设置</h2>
                <div class="form-group">
                    <label for="textWatermarkContent">文字内容:</label>
                    <input type="text" id="textWatermarkContent" value="您的水印文字">
                </div>
                <div class="form-group">
                    <label for="textWatermarkFont">字体:</label>
                    <select id="textWatermarkFont">
                        <option value="Arial">Arial</option>
                        <option value="Verdana">Verdana</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Courier New">Courier New</option>
                        <option value="Georgia">Georgia</option>
                        <option value="宋体">宋体</option>
                        <option value="黑体">黑体</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="textWatermarkSize">大小:</label>
                    <input type="number" id="textWatermarkSize" value="30" min="10" max="200">
                </div>
                <div class="form-group">
                    <label for="textWatermarkColor">颜色:</label>
                    <input type="color" id="textWatermarkColor" value="#000000">
                </div>
                <div class="form-group">
                    <label for="textWatermarkPosition">位置:</label>
                    <select id="textWatermarkPosition">
                        <option value="topLeft">左上角</option>
                        <option value="topRight">右上角</option>
                        <option value="bottomLeft">左下角</option>
                        <option value="bottomRight" selected>右下角</option>
                        <option value="center">中心</option>
                        <option value="tile">平铺</option>
                        <option value="free">自由 (拖拽)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="textWatermarkAngle">角度:</label>
                    <input type="range" id="textWatermarkAngle" min="-180" max="180" step="1" value="0">
                    <span id="textWatermarkAngleValue">0°</span>
                </div>
                <div class="form-group" id="textWatermarkSpacingGroup" style="display: none;">
                    <label for="textWatermarkSpacing">间隔 (平铺模式):</label>
                    <input type="number" id="textWatermarkSpacing" value="20" min="0">
                </div>
                <div class="form-group">
                    <label for="textWatermarkOpacity">透明度:</label>
                    <input type="range" id="textWatermarkOpacity" min="0" max="1" step="0.01" value="0.5">
                    <span id="textWatermarkOpacityValue">50%</span>
                </div>
            </div>

            <div id="imageWatermarkSettingsTab" class="tab-content">
                <h2>图片水印设置</h2>
                <div class="form-group">
                    <label for="imageWatermarkUpload">选择图片水印 (Logo):</label>
                    <input type="file" id="imageWatermarkUpload" accept="image/*">
                </div>
                <div class="form-group">
                    <label for="imageWatermarkSize">大小 (百分比):</label>
                    <input type="number" id="imageWatermarkSize" value="20" min="1" max="100">
                </div>
                <div class="form-group">
                    <label for="imageWatermarkPosition">位置:</label>
                    <select id="imageWatermarkPosition">
                        <option value="topLeft">左上角</option>
                        <option value="topRight">右上角</option>
                        <option value="bottomLeft">左下角</option>
                        <option value="bottomRight" selected>右下角</option>
                        <option value="center">中心</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="imageWatermarkOpacity">透明度:</label>
                    <input type="range" id="imageWatermarkOpacity" min="0" max="1" step="0.01" value="0.7">
                    <span id="imageWatermarkOpacityValue">70%</span>
                </div>
            </div>
        </div>

        <div class="preview">
            <h2>水印预览</h2>
            <div class="preview-area">
                <canvas id="watermarkCanvas"></canvas>
            </div>
            <div id="imagePreviewContainer" style="margin-top: 10px; display: flex; flex-wrap: wrap; gap: 10px;">
                <!-- Thumbnails for multiple images will go here -->
            </div>
            <div class="form-group">
                <label for="exportFormat">导出格式:</label>
                <select id="exportFormat">
                    <option value="image/png" selected>PNG</option>
                    <option value="image/jpeg">JPEG</option>
                    <option value="image/jpg">JPG</option>
                </select>
            </div>
            <button class="download-btn" id="downloadImage">下载处理后的图片</button>
            <button class="download-btn" id="downloadAllImages" style="margin-top:10px; background-color: #17a2b8; display:none;">下载所有已处理图片 (ZIP)</button>
        </div>
    </div>

    <script>
        // Constants for DOM elements
        const imageUpload = document.getElementById('imageUpload');
        const textWatermarkContent = document.getElementById('textWatermarkContent');
        const textWatermarkFont = document.getElementById('textWatermarkFont');
        const textWatermarkSize = document.getElementById('textWatermarkSize');
        const textWatermarkColor = document.getElementById('textWatermarkColor');
        const textWatermarkPosition = document.getElementById('textWatermarkPosition');
        const textWatermarkOpacity = document.getElementById('textWatermarkOpacity');
        const textWatermarkOpacityValue = document.getElementById('textWatermarkOpacityValue');
        const textWatermarkAngle = document.getElementById('textWatermarkAngle');
        const textWatermarkAngleValue = document.getElementById('textWatermarkAngleValue');
        const textWatermarkSpacingGroup = document.getElementById('textWatermarkSpacingGroup');
        const textWatermarkSpacing = document.getElementById('textWatermarkSpacing');

        const imageWatermarkUpload = document.getElementById('imageWatermarkUpload');
        const imageWatermarkSize = document.getElementById('imageWatermarkSize');
        const imageWatermarkPosition = document.getElementById('imageWatermarkPosition');
        const imageWatermarkOpacity = document.getElementById('imageWatermarkOpacity');
        const imageWatermarkOpacityValue = document.getElementById('imageWatermarkOpacityValue');

        const watermarkCanvas = document.getElementById('watermarkCanvas');
        const ctx = watermarkCanvas.getContext('2d');
        const downloadImageBtn = document.getElementById('downloadImage');
        const exportFormat = document.getElementById('exportFormat');
        const downloadAllImagesBtn = document.getElementById('downloadAllImages');
        const imagePreviewContainer = document.getElementById('imagePreviewContainer');

        // Tab navigation
        const tabButtons = document.querySelectorAll('.tab-nav-button');
        const tabContents = document.querySelectorAll('.tab-content');

        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');

                tabContents.forEach(content => content.classList.remove('active'));
                document.getElementById(button.dataset.tab).classList.add('active');
            });
        });


        let originalImage = null; // For single image preview
        let watermarkImage = null; // For image watermark
        let uploadedFiles = []; // To store multiple uploaded files for batch processing

        let isDraggingText = false;
        let textWatermarkFreeX = 150; 
        let textWatermarkFreeY = 150;
        let dragStartX, dragStartY;
        let textDragOffsetX, textDragOffsetY;

        // Update opacity/angle display
        textWatermarkOpacity.addEventListener('input', () => {
            textWatermarkOpacityValue.textContent = `${Math.round(textWatermarkOpacity.value * 100)}%`;
            drawWatermark();
        });
        textWatermarkAngle.addEventListener('input', () => {
            textWatermarkAngleValue.textContent = `${textWatermarkAngle.value}°`;
            drawWatermark();
        });
        imageWatermarkOpacity.addEventListener('input', () => {
            imageWatermarkOpacityValue.textContent = `${Math.round(imageWatermarkOpacity.value * 100)}%`;
            drawWatermark();
        });

        textWatermarkPosition.addEventListener('change', () => {
            textWatermarkSpacingGroup.style.display = textWatermarkPosition.value === 'tile' ? 'block' : 'none';
            if (textWatermarkPosition.value !== 'free' && originalImage) {
                 watermarkCanvas.style.cursor = 'default';
            } else if (textWatermarkPosition.value === 'free' && originalImage) {
                 watermarkCanvas.style.cursor = 'grab';
            }
            drawWatermark();
        });

        imageUpload.addEventListener('change', (e) => {
            uploadedFiles = Array.from(e.target.files);
            imagePreviewContainer.innerHTML = ''; // Clear previous previews

            if (uploadedFiles.length > 0) {
                // Display the first image in the main canvas for settings adjustment
                loadAndDisplayImage(uploadedFiles[0], true); 
                downloadAllImagesBtn.style.display = uploadedFiles.length > 1 ? 'block' : 'none';

                // Create thumbnails for all uploaded images
                uploadedFiles.forEach((file, index) => {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const imgThumb = document.createElement('img');
                        imgThumb.src = event.target.result;
                        imgThumb.style.width = '80px';
                        imgThumb.style.height = '80px';
                        imgThumb.style.objectFit = 'cover';
                        imgThumb.style.border = '1px solid #ddd';
                        imgThumb.style.cursor = 'pointer';
                        imgThumb.title = file.name;
                        imgThumb.addEventListener('click', () => loadAndDisplayImage(file, true));
                        imagePreviewContainer.appendChild(imgThumb);
                    };
                    reader.readAsDataURL(file);
                });
            } else {
                originalImage = null;
                drawWatermark(); // Clear canvas
                downloadAllImagesBtn.style.display = 'none';
            }
        });

        function loadAndDisplayImage(file, isMainPreview) {
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    if (isMainPreview) {
                        originalImage = img;
                        textWatermarkFreeX = watermarkCanvas.width / 2; 
                        textWatermarkFreeY = watermarkCanvas.height / 2;
                        drawWatermark();
                    }
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        imageWatermarkUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    watermarkImage = new Image();
                    watermarkImage.onload = () => drawWatermark();
                    watermarkImage.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        // Event listeners for controls
        [
            textWatermarkContent, textWatermarkFont, textWatermarkSize, textWatermarkColor,
            textWatermarkOpacity, textWatermarkAngle, textWatermarkSpacing,
            imageWatermarkSize, imageWatermarkPosition, imageWatermarkOpacity, exportFormat
        ].forEach(element => {
            element.addEventListener('input', () => drawWatermark());
            element.addEventListener('change', () => drawWatermark());
        });
        textWatermarkPosition.addEventListener('change', () => drawWatermark()); // Already handled above, but ensure it calls draw

        // Drag and Drop for Free Text Watermark
        watermarkCanvas.addEventListener('mousedown', (e) => {
            if (textWatermarkPosition.value !== 'free' || !originalImage) return;
            const rect = watermarkCanvas.getBoundingClientRect();
            const scaleX = watermarkCanvas.width / rect.width;
            const scaleY = watermarkCanvas.height / rect.height;
            const mouseX = (e.clientX - rect.left) * scaleX;
            const mouseY = (e.clientY - rect.top) * scaleY;

            const text = textWatermarkContent.value;
            const fontSize = parseInt(textWatermarkSize.value);
            ctx.font = `${fontSize}px ${textWatermarkFont.value}`;
            const textMetrics = ctx.measureText(text);
            const textWidth = textMetrics.width;
            const textHeight = fontSize;

            if (mouseX >= textWatermarkFreeX && mouseX <= textWatermarkFreeX + textWidth &&
                mouseY >= textWatermarkFreeY && mouseY <= textWatermarkFreeY + textHeight) {
                isDraggingText = true;
                textDragOffsetX = mouseX - textWatermarkFreeX;
                textDragOffsetY = mouseY - textWatermarkFreeY;
                watermarkCanvas.style.cursor = 'grabbing';
            }
        });

        watermarkCanvas.addEventListener('mousemove', (e) => {
            if (!isDraggingText || textWatermarkPosition.value !== 'free' || !originalImage) return;
            const rect = watermarkCanvas.getBoundingClientRect();
            const scaleX = watermarkCanvas.width / rect.width;
            const scaleY = watermarkCanvas.height / rect.height;
            const mouseX = (e.clientX - rect.left) * scaleX;
            const mouseY = (e.clientY - rect.top) * scaleY;
            textWatermarkFreeX = mouseX - textDragOffsetX;
            textWatermarkFreeY = mouseY - textDragOffsetY;
            drawWatermark();
        });

        watermarkCanvas.addEventListener('mouseup', () => {
            if (isDraggingText) {
                isDraggingText = false;
                watermarkCanvas.style.cursor = (textWatermarkPosition.value === 'free' && originalImage) ? 'grab' : 'default';
            }
        });

        watermarkCanvas.addEventListener('mouseleave', () => {
            if (isDraggingText) {
                isDraggingText = false;
                watermarkCanvas.style.cursor = (textWatermarkPosition.value === 'free' && originalImage) ? 'grab' : 'default';
            }
        });

        function drawWatermark(imageToProcess = originalImage) {
            if (!imageToProcess) {
                ctx.clearRect(0, 0, watermarkCanvas.width, watermarkCanvas.height);
                watermarkCanvas.style.cursor = 'default';
                return null; // Return null if no image to process
            }
            
            const isMainPreviewCanvas = (imageToProcess === originalImage);

            if (isMainPreviewCanvas) {
                 if (textWatermarkPosition.value === 'free') {
                    watermarkCanvas.style.cursor = isDraggingText ? 'grabbing' : 'grab';
                } else {
                    watermarkCanvas.style.cursor = 'default';
                }
            }


            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = imageToProcess.naturalWidth;
            tempCanvas.height = imageToProcess.naturalHeight;
            tempCtx.drawImage(imageToProcess, 0, 0);

            const text = textWatermarkContent.value;
            const fontSize = parseInt(textWatermarkSize.value);
            const font = `${fontSize}px ${textWatermarkFont.value}`;
            const color = textWatermarkColor.value;
            const opacity = parseFloat(textWatermarkOpacity.value);
            const position = textWatermarkPosition.value;
            const angle = parseInt(textWatermarkAngle.value);
            const angleInRadians = angle * Math.PI / 180;

            tempCtx.font = font;
            tempCtx.fillStyle = color;
            tempCtx.globalAlpha = opacity;
            
            const textMetrics = tempCtx.measureText(text);
            const textWidth = textMetrics.width;
            const textHeight = fontSize;

            if (position === 'tile') {
                const spacing = parseInt(textWatermarkSpacing.value) || 20;
                tempCtx.textAlign = 'left';
                tempCtx.textBaseline = 'top';
                const absCos = Math.abs(Math.cos(angleInRadians));
                const absSin = Math.abs(Math.sin(angleInRadians));
                const rotatedTextWidth = textWidth * absCos + textHeight * absSin;
                const rotatedTextHeight = textWidth * absSin + textHeight * absCos;
                const tileStepX = rotatedTextWidth + spacing;
                const tileStepY = rotatedTextHeight + spacing;

                for (let ty = 0; ty < tempCanvas.height + rotatedTextHeight; ty += tileStepY) {
                    for (let tx = 0; tx < tempCanvas.width + rotatedTextWidth; tx += tileStepX) {
                        tempCtx.save();
                        tempCtx.translate(tx + textWidth / 2, ty + textHeight / 2);
                        tempCtx.rotate(angleInRadians);
                        tempCtx.fillText(text, -textWidth / 2, -textHeight / 2);
                        tempCtx.restore();
                    }
                }
            } else if (position === 'free') {
                tempCtx.save();
                tempCtx.textAlign = 'left'; 
                tempCtx.textBaseline = 'top';
                tempCtx.translate(textWatermarkFreeX + textWidth / 2, textWatermarkFreeY + textHeight / 2);
                tempCtx.rotate(angleInRadians);
                tempCtx.fillText(text, -textWidth / 2, -textHeight / 2); // Centered after rotation
                tempCtx.restore();
            } else { // Handle other positions: topLeft, topRight, bottomLeft, bottomRight, center
                let x, y;
                tempCtx.textAlign = 'left'; // Default for these
                tempCtx.textBaseline = 'top'; // Default for these

                // Calculate initial x, y based on position (before rotation)
                switch (position) {
                    case 'topLeft':
                        x = 10;
                        y = 10;
                        break;
                    case 'topRight':
                        x = tempCanvas.width - textWidth - 10;
                        y = 10;
                        break;
                    case 'bottomLeft':
                        x = 10;
                        y = tempCanvas.height - textHeight - 10;
                        break;
                    case 'bottomRight':
                        x = tempCanvas.width - textWidth - 10;
                        y = tempCanvas.height - textHeight - 10;
                        break;
                    case 'center':
                        x = (tempCanvas.width - textWidth) / 2;
                        y = (tempCanvas.height - textHeight) / 2;
                        break;
                }

                tempCtx.save();
                // Translate to the pivot point for rotation (center of the text)
                tempCtx.translate(x + textWidth / 2, y + textHeight / 2);
                tempCtx.rotate(angleInRadians);
                // Draw text relative to the new (0,0) which is the center of the text
                tempCtx.fillText(text, -textWidth / 2, -textHeight / 2);
                tempCtx.restore();
            }

            // Draw image watermark if selected
            if (watermarkImage && document.getElementById('imageWatermarkSettingsTab').classList.contains('active')) {
                const imgWatermarkSizePercent = parseInt(imageWatermarkSize.value) / 100;
                const imgWatermarkWidth = imageToProcess.naturalWidth * imgWatermarkSizePercent;
                const imgWatermarkHeight = (watermarkImage.naturalHeight / watermarkImage.naturalWidth) * imgWatermarkWidth;
                const imgPosition = imageWatermarkPosition.value;
                const imgOpacity = parseFloat(imageWatermarkOpacity.value);

                let imgX, imgY;
                switch (imgPosition) {
                    case 'topLeft':
                        imgX = 10;
                        imgY = 10;
                        break;
                    case 'topRight':
                        imgX = tempCanvas.width - imgWatermarkWidth - 10;
                        imgY = 10;
                        break;
                    case 'bottomLeft':
                        imgX = 10;
                        imgY = tempCanvas.height - imgWatermarkHeight - 10;
                        break;
                    case 'bottomRight':
                        imgX = tempCanvas.width - imgWatermarkWidth - 10;
                        imgY = tempCanvas.height - imgWatermarkHeight - 10;
                        break;
                    case 'center':
                        imgX = (tempCanvas.width - imgWatermarkWidth) / 2;
                        imgY = (tempCanvas.height - imgWatermarkHeight) / 2;
                        break;
                }
                tempCtx.globalAlpha = imgOpacity;
                tempCtx.drawImage(watermarkImage, imgX, imgY, imgWatermarkWidth, imgWatermarkHeight);
                tempCtx.globalAlpha = 1; // Reset globalAlpha
            }

            // Draw the processed image from tempCanvas to the main visible canvas
            if (isMainPreviewCanvas) {
                watermarkCanvas.width = imageToProcess.naturalWidth;
                watermarkCanvas.height = imageToProcess.naturalHeight;
                ctx.clearRect(0, 0, watermarkCanvas.width, watermarkCanvas.height);
                ctx.drawImage(tempCanvas, 0, 0);
            }
            
            return tempCanvas.toDataURL(exportFormat.value || 'image/png'); // Return data URL for download
        }

        downloadImageBtn.addEventListener('click', () => {
            if (!originalImage) {
                alert('请先上传图片！');
                return;
            }
            const dataUrl = drawWatermark(originalImage);
            if (dataUrl) {
                const a = document.createElement('a');
                const format = exportFormat.value.split('/')[1] || 'png';
                a.href = dataUrl;
                a.download = `watermarked_image.${format}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }
        });

        downloadAllImagesBtn.addEventListener('click', async () => {
            if (uploadedFiles.length === 0) {
                alert('请先上传图片！');
                return;
            }
            if (typeof JSZip === 'undefined') {
                alert('JSZip 库未加载，无法打包下载。请检查网络连接或稍后再试。');
                // You might want to load JSZip dynamically here if it's not already included.
                // For now, we'll just alert.
                // Example:
                // const script = document.createElement('script');
                // script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                // script.onload = () => { /* now call a function that uses JSZip */ };
                // document.head.appendChild(script);
                return;
            }

            const zip = new JSZip();
            const processingPromises = uploadedFiles.map(async (file, index) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            const dataUrl = drawWatermark(img); // Process this specific image
                            if (dataUrl) {
                                const format = exportFormat.value.split('/')[1] || 'png';
                                const fileName = `watermarked_${file.name.split('.')[0]}_${index}.${format}`;
                                // JSZip needs blob data, not dataURL directly for addAsync
                                fetch(dataUrl)
                                    .then(res => res.blob())
                                    .then(blob => {
                                        zip.file(fileName, blob);
                                        resolve();
                                    })
                                    .catch(reject);
                            } else {
                                reject(new Error(`无法处理图片: ${file.name}`));
                            }
                        };
                        img.onerror = () => reject(new Error(`无法加载图片: ${file.name}`));
                        img.src = event.target.result;
                    };
                    reader.onerror = () => reject(new Error(`无法读取文件: ${file.name}`));
                    reader.readAsDataURL(file);
                });
            });

            try {
                await Promise.all(processingPromises);
                zip.generateAsync({ type: "blob" })
                    .then(function(content) {
                        const a = document.createElement('a');
                        a.href = URL.createObjectURL(content);
                        a.download = "watermarked_images.zip";
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(a.href);
                    });
            } catch (error) {
                console.error("批量处理或打包ZIP时出错:", error);
                alert(`处理图片时发生错误: ${error.message}`);
            }
        });

        // Initial draw if any default values need to be reflected (e.g., spacing group visibility)
        textWatermarkPosition.dispatchEvent(new Event('change'));
        
        // Load JSZip - you might want to put this in a more robust loading mechanism
        // or include it directly in your HTML if it's always needed.
        (function loadJSZip() {
            if (typeof JSZip === 'undefined') {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                script.integrity = 'sha512-XMVd28F1oH/O71fzwBnV7HucLxVwtxf26XV8P4wPk26EDxuGZ91N8bsOttmnomcCD3CS5ZMRL50H0GgOHvegtg==';
                script.crossOrigin = 'anonymous';
                script.referrerPolicy = 'no-referrer';
                script.onload = () => console.log('JSZip loaded successfully.');
                script.onerror = () => console.error('Failed to load JSZip.');
                document.head.appendChild(script);
            }
        })();

    </script>
</body>
</html>