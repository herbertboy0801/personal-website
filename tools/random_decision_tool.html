<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éšæœºå†³ç­–å·¥å…·</title>
    <style>
        /* CSS æ ·å¼å°†åœ¨è¿™é‡Œæ·»åŠ  */
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            min-height: 100vh;
            background-color: #f0f2f5;
            color: #333;
        }

        .container {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 600px;
            margin-top: 20px;
        }

        h1 {
            text-align: center;
            color: #1877f2;
            margin-bottom: 25px;
        }

        .options-input-area {
            display: flex;
            margin-bottom: 20px;
            gap: 10px; /* è¾“å…¥æ¡†å’ŒæŒ‰é’®ä¹‹é—´çš„é—´è· */
        }

        .options-input-area input[type="text"] {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }

        .options-input-area button {
            padding: 10px 15px;
            background-color: #1877f2;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s ease;
        }

        .options-input-area button:hover {
            background-color: #166fe5;
        }

        .options-display-area h2 {
            font-size: 18px;
            color: #333;
            margin-bottom: 10px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        #options-list {
            list-style-type: none;
            padding: 0;
        }

        #options-list li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #f0f0f0;
            background-color: #fff;
            margin-bottom: 5px;
            border-radius: 4px;
        }

        #options-list li:last-child {
            border-bottom: none;
        }

        #options-list li span {
            flex-grow: 1;
            margin-right: 10px; /* æ–‡æœ¬å’ŒæŒ‰é’®ç»„çš„é—´è· */
        }

        .option-buttons button {
            margin-left: 8px;
            padding: 6px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s ease;
        }

        .edit-option-btn {
            background-color: #ffc107; /* é»„è‰² */
            color: #333;
        }

        .edit-option-btn:hover {
            background-color: #e0a800;
        }

        .delete-option-btn {
            background-color: #dc3545; /* çº¢è‰² */
            color: white;
        }

        .delete-option-btn:hover {
            background-color: #c82333;
        }

        .decision-controls, .decision-result-area, .wheel-area {
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
        }

        .decision-controls h2, .decision-result-area h2, .wheel-area h2 {
            font-size: 18px;
            color: #333;
            margin-bottom: 15px;
        }

        .mode-selection {
            margin-bottom: 15px;
            display: flex;
            gap: 20px; /* é€‰é¡¹é—´è· */
        }

        .mode-selection label {
            cursor: pointer;
            font-size: 16px;
        }

        #start-decision-btn {
            padding: 12px 25px;
            background-color: #28a745; /* ç»¿è‰² */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
            transition: background-color 0.3s ease;
            display: block; /* è®©æŒ‰é’®å æ®æ•´è¡Œæˆ–æ ¹æ®éœ€è¦è°ƒæ•´ */
            margin: 0 auto; /* å±…ä¸­ */
            min-width: 150px;
        }

        #start-decision-btn:hover {
            background-color: #218838;
        }

        #start-decision-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        #decision-result-text {
            font-size: 20px;
            font-weight: bold;
            color: #1877f2;
            text-align: center;
            padding: 15px;
            background-color: #e7f3ff;
            border-radius: 4px;
            min-height: 30px;
        }
        
        .wheel-area {
            text-align: center; /* ä½¿ canvas å±…ä¸­ */
        }

        #decision-wheel-canvas {
            border: 1px solid #ccc;
            border-radius: 50%; /* å¦‚æœå¸Œæœ›canvasæœ¬èº«ä¹Ÿæ˜¯åœ†çš„ï¼ˆè™½ç„¶å†…å®¹ä¼šæ˜¯åœ†çš„ï¼‰ */
        }

        .history-area {
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
        }

        .history-area h2 {
            font-size: 18px;
            color: #333;
            margin-bottom: 15px;
        }

        #history-list {
            list-style-type: none;
            padding: 0;
            max-height: 200px; /* é™åˆ¶æœ€å¤§é«˜åº¦ï¼Œå‡ºç°æ»šåŠ¨æ¡ */
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        #history-list li {
            padding: 8px 12px;
            border-bottom: 1px solid #f0f0f0;
            font-size: 14px;
            color: #555;
        }

        #history-list li:last-child {
            border-bottom: none;
        }

        #clear-history-btn {
            background-color: #6c757d; /* ç°è‰² */
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 15px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s ease;
            display: block; /* or inline-block depending on layout preference */
            margin-top: 10px;
        }

        #clear-history-btn:hover {
            background-color: #5a6268;
        }


        /* å“åº”å¼è°ƒæ•´ */
        @media (max-width: 480px) {
            .options-input-area {
                flex-direction: column;
            }
            .options-input-area input[type="text"] {
                margin-bottom: 10px;
            }
            #options-list li {
                flex-direction: column;
                align-items: flex-start;
            }
            .option-buttons {
                margin-top: 8px;
                width: 100%;
                display: flex;
                justify-content: flex-end;
            }
            .option-buttons button {
                margin-left: 0;
                margin-right: 8px; /* æŒ‰é’®é—´è·è°ƒæ•´ */
            }
            .option-buttons button:last-child {
                margin-right: 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>éšæœºå†³ç­–å·¥å…·</h1>

        <div class="options-input-area">
            <input type="text" id="option-input" placeholder="è¾“å…¥é€‰é¡¹...">
            <button id="add-option-btn">æ·»åŠ é€‰é¡¹</button>
        </div>

        <div class="options-display-area">
            <h2>å½“å‰é€‰é¡¹ï¼š</h2>
            <ul id="options-list">
                <!-- é€‰é¡¹å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
            </ul>
        </div>

        <div class="decision-controls">
            <h2>å†³ç­–æ¨¡å¼ï¼š</h2>
            <div class="mode-selection">
                <label>
                    <input type="radio" name="decision-mode" value="simple" checked> ç®€å•æ¨¡å¼
                </label>
                <label>
                    <input type="radio" name="decision-mode" value="wheel"> è½¬ç›˜æ¨¡å¼
                </label>
            </div>
            <button id="start-decision-btn">å¼€å§‹å†³ç­–</button>
        </div>

        <div class="decision-result-area">
            <h2>å†³ç­–ç»“æœï¼š</h2>
            <p id="decision-result-text">- ç­‰å¾…å†³ç­– -</p>
        </div>

        <div class="wheel-area" style="display: none;"> <!-- åˆå§‹éšè—è½¬ç›˜åŒºåŸŸ -->
            <h2>å†³ç­–è½¬ç›˜ï¼š</h2>
            <canvas id="decision-wheel-canvas" width="300" height="300"></canvas>
            <!-- è½¬ç›˜åŠ¨ç”»ç›¸å…³çš„å…ƒç´ å¯ä»¥åç»­æ·»åŠ  -->
        </div>

        <div class="history-area">
            <h2>å†³ç­–å†å²ï¼š</h2>
            <ul id="history-list">
                <!-- å†å²è®°å½•å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
            </ul>
            <button id="clear-history-btn" style="display:none;">æ¸…ç©ºå†å²</button>
        </div>
        
        <!-- å…¶ä»–åŠŸèƒ½æ¨¡å—å°†åœ¨è¿™é‡Œæ·»åŠ  -->

    </div>

    <script>
        const optionInput = document.getElementById('option-input');
        const addOptionBtn = document.getElementById('add-option-btn');
        const optionsList = document.getElementById('options-list');
        const startDecisionBtn = document.getElementById('start-decision-btn');
        const decisionResultText = document.getElementById('decision-result-text');
        const decisionModes = document.querySelectorAll('input[name="decision-mode"]');
        const wheelArea = document.querySelector('.wheel-area');
        const decisionResultArea = document.querySelector('.decision-result-area');
        const decisionWheelCanvas = document.getElementById('decision-wheel-canvas');
        const ctx = decisionWheelCanvas.getContext('2d');
        const historyList = document.getElementById('history-list');
        const clearHistoryBtn = document.getElementById('clear-history-btn');

        let options = [];
        let editingIndex = -1; // -1 è¡¨ç¤ºä¸åœ¨ç¼–è¾‘æ¨¡å¼, å¤§äºç­‰äº0è¡¨ç¤ºæ­£åœ¨ç¼–è¾‘çš„é€‰é¡¹çš„ç´¢å¼•
        let decisionHistory = JSON.parse(localStorage.getItem('decisionHistory')) || []; // ä»localStorageåŠ è½½å†å²
        const MAX_HISTORY_LENGTH = 5;

        const MAX_OPTIONS = 10;
        const MIN_OPTIONS_FOR_DECISION = 2;

        function renderOptions() {
            optionsList.innerHTML = ''; // æ¸…ç©ºåˆ—è¡¨
            options.forEach((option, index) => {
                const listItem = document.createElement('li');
                
                const textSpan = document.createElement('span');
                textSpan.textContent = option;
                listItem.appendChild(textSpan);

                const editBtn = document.createElement('button');
                editBtn.textContent = 'ç¼–è¾‘';
                editBtn.classList.add('edit-option-btn');
                editBtn.onclick = () => startEditOption(index);

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'åˆ é™¤';
                deleteBtn.classList.add('delete-option-btn');
                deleteBtn.onclick = () => deleteOption(index);

                const buttonsDiv = document.createElement('div');
                buttonsDiv.classList.add('option-buttons');
                buttonsDiv.appendChild(editBtn);
                buttonsDiv.appendChild(deleteBtn);
                listItem.appendChild(buttonsDiv);

                optionsList.appendChild(listItem);
            });
        }

        function addOrUpdateOption() {
            const optionText = optionInput.value.trim();
            if (optionText === "") {
                alert("é€‰é¡¹ä¸èƒ½ä¸ºç©ºï¼");
                return;
            }

            if (editingIndex > -1) { // æ›´æ–°æ¨¡å¼
                if (options.some((opt, idx) => opt === optionText && idx !== editingIndex)) {
                    alert("è¯¥é€‰é¡¹å·²å­˜åœ¨ï¼");
                    return;
                }
                options[editingIndex] = optionText;
                editingIndex = -1;
                addOptionBtn.textContent = 'æ·»åŠ é€‰é¡¹';
            } else { // æ·»åŠ æ¨¡å¼
                if (options.length >= MAX_OPTIONS) {
                    alert(`æœ€å¤šåªèƒ½æ·»åŠ  ${MAX_OPTIONS} ä¸ªé€‰é¡¹ï¼`);
                    return;
                }
                if (options.includes(optionText)) {
                    alert("è¯¥é€‰é¡¹å·²å­˜åœ¨ï¼");
                    return;
                }
                options.push(optionText);
            }
            renderOptions();
            optionInput.value = '';
            optionInput.focus();
        }

        function startEditOption(index) {
            optionInput.value = options[index];
            editingIndex = index;
            addOptionBtn.textContent = 'æ›´æ–°é€‰é¡¹';
            optionInput.focus();
        }

        function deleteOption(index) {
            if (!confirm(`ç¡®å®šè¦åˆ é™¤é€‰é¡¹ "${options[index]}" å—ï¼Ÿ`)) {
                return;
            }
            options.splice(index, 1);
            renderOptions();
            if (editingIndex === index || options.length === 0) {
                editingIndex = -1;
                optionInput.value = '';
                addOptionBtn.textContent = 'æ·»åŠ é€‰é¡¹';
            } else if (editingIndex > index) {
                editingIndex--;
            }
        }

        addOptionBtn.addEventListener('click', addOrUpdateOption);

        optionInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                addOrUpdateOption();
            }
        });

        decisionModes.forEach(radio => {
            radio.addEventListener('change', () => {
                if (radio.value === 'simple' && radio.checked) {
                    decisionResultArea.style.display = 'block';
                    wheelArea.style.display = 'none';
                    decisionResultText.textContent = '- ç­‰å¾…å†³ç­– -'; // é‡ç½®ç»“æœ
                } else if (radio.value === 'wheel' && radio.checked) {
                    decisionResultArea.style.display = 'none';
                    wheelArea.style.display = 'block';
                    if (options.length >= MIN_OPTIONS_FOR_DECISION) {
                        drawWheel();
                    } else {
                        ctx.clearRect(0, 0, decisionWheelCanvas.width, decisionWheelCanvas.height);
                        ctx.save();
                        ctx.textAlign = 'center';
                        ctx.fillStyle = '#777';
                        ctx.font = '16px Arial';
                        ctx.fillText('è¯·è‡³å°‘æ·»åŠ 2ä¸ªé€‰é¡¹æ‰èƒ½ç»˜åˆ¶è½¬ç›˜', decisionWheelCanvas.width / 2, decisionWheelCanvas.height / 2);
                        ctx.restore();
                    }
                }
            });
        });

        const wheelColors = ["#FFC0CB", "#ADD8E6", "#90EE90", "#FFD700", "#FFA07A", "#DDA0DD", "#87CEFA", "#F0E68C", "#FFB6C1", "#E6E6FA"];

        function drawWheel(rotationAngle = 0) {
            const numOptions = options.length;
            if (numOptions < MIN_OPTIONS_FOR_DECISION) {
                 ctx.clearRect(0, 0, decisionWheelCanvas.width, decisionWheelCanvas.height);
                 ctx.save();
                 ctx.textAlign = 'center';
                 ctx.fillStyle = '#777';
                 ctx.font = '16px Arial';
                 ctx.fillText('é€‰é¡¹ä¸è¶³', decisionWheelCanvas.width / 2, decisionWheelCanvas.height / 2);
                 ctx.restore();
                return;
            }

            const arcSize = (2 * Math.PI) / numOptions;
            const centerX = decisionWheelCanvas.width / 2;
            const centerY = decisionWheelCanvas.height / 2;
            const radius = Math.min(centerX, centerY) * 0.9; // ç•™å‡ºä¸€äº›è¾¹è·

            ctx.clearRect(0, 0, decisionWheelCanvas.width, decisionWheelCanvas.height);
            ctx.save(); // ä¿å­˜åˆå§‹çŠ¶æ€
            ctx.translate(centerX, centerY); // å°†åŸç‚¹ç§»åˆ°ç”»å¸ƒä¸­å¿ƒ
            ctx.rotate(rotationAngle); // åº”ç”¨æ—‹è½¬è§’åº¦ (ç”¨äºåŠ¨ç”»)
            ctx.translate(-centerX, -centerY); // å°†åŸç‚¹ç§»å›

            for (let i = 0; i < numOptions; i++) {
                const angle = i * arcSize;

                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, angle, angle + arcSize);
                ctx.lineTo(centerX, centerY);
                ctx.closePath();

                ctx.fillStyle = wheelColors[i % wheelColors.length];
                ctx.fill();
                ctx.strokeStyle = '#555'; // æ‰‡å½¢è¾¹æ¡†é¢œè‰²
                ctx.lineWidth = 1;
                ctx.stroke();

                // ç»˜åˆ¶æ–‡å­—
                ctx.save();
                ctx.translate(centerX, centerY); // å°†åŸç‚¹ç§»åˆ°ç”»å¸ƒä¸­å¿ƒä»¥ä¾¿æ—‹è½¬æ–‡å­—
                ctx.rotate(angle + arcSize / 2); // æ—‹è½¬åˆ°æ‰‡å½¢ä¸­é—´

                ctx.textAlign = "right"; // æ–‡å­—åŸºçº¿å¯¹é½æ‰‡å½¢ä¸­å¿ƒçº¿å³ä¾§
                ctx.fillStyle = "#333"; // æ–‡å­—é¢œè‰²
                ctx.font = "bold 14px Arial";
                
                // é™åˆ¶æ–‡å­—é•¿åº¦
                let optionText = options[i];
                const maxTextWidth = radius * 0.7; // æ–‡å­—æœ€å¤§å®½åº¦ä¸è¶…è¿‡åŠå¾„çš„70%
                if (ctx.measureText(optionText).width > maxTextWidth) {
                    while(ctx.measureText(optionText + '...').width > maxTextWidth && optionText.length > 0) {
                        optionText = optionText.substring(0, optionText.length - 1);
                    }
                    optionText += '...';
                }
                ctx.fillText(optionText, radius * 0.95, 0); // åœ¨åŠå¾„çš„95%å¤„ç»˜åˆ¶æ–‡å­—ï¼Œ0è¡¨ç¤ºåœ¨æ—‹è½¬åçš„xè½´ä¸Š
                ctx.restore(); // æ¢å¤ä¿å­˜çš„ç”»å¸ƒçŠ¶æ€ï¼ˆä¸»è¦æ˜¯æ—‹è½¬å’Œå¹³ç§»ï¼‰
            }
            ctx.restore(); // æ¢å¤åˆå§‹çŠ¶æ€

            // ç»˜åˆ¶æŒ‡é’ˆ
            ctx.save();
            ctx.translate(centerX, centerY); // ä¸­å¿ƒç‚¹
            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.moveTo(0, -radius * 0.1); // æŒ‡é’ˆé¡¶éƒ¨
            ctx.lineTo(radius * 0.05, 0);  // æŒ‡é’ˆå³ä¸‹è§’
            ctx.lineTo(-radius * 0.05, 0); // æŒ‡é’ˆå·¦ä¸‹è§’
            ctx.closePath();
            ctx.fill();

            // ä¸­å¿ƒåœ†ç‚¹
            ctx.beginPath();
            ctx.arc(0, 0, radius * 0.05, 0, 2 * Math.PI);
            ctx.fillStyle = '#666';
            ctx.fill();
            ctx.restore();
        }

        let currentRotationAngle = 0; // å½“å‰è½¬ç›˜çš„æ—‹è½¬è§’åº¦ï¼ŒåŠ¨ç”»ç»“æŸåä¼šæ˜¯æœ€ç»ˆè§’åº¦
        let spinAnimationId = null; // ç”¨äºå­˜å‚¨ requestAnimationFrame çš„ ID
        let isSpinning = false; // é˜²æ­¢é‡å¤ç‚¹å‡»

        function spinWheel() {
            if (isSpinning || options.length < MIN_OPTIONS_FOR_DECISION) return;
            isSpinning = true;
            startDecisionBtn.disabled = true; // ç¦ç”¨æŒ‰é’®é˜²æ­¢åŠ¨ç”»æœŸé—´å†æ¬¡ç‚¹å‡»

            if (spinAnimationId) cancelAnimationFrame(spinAnimationId);

            const numOptions = options.length;
            const arcSize = (2 * Math.PI) / numOptions;
            const targetOptionIndex = Math.floor(Math.random() * numOptions);
            
            // ç›®æ ‡æ˜¯è®©æŒ‡é’ˆï¼ˆå›ºå®šå‘ä¸Šï¼‰æŒ‡å‘ç›®æ ‡æ‰‡åŒºçš„ä¸­é—´ã€‚
            // ç›®æ ‡æ‰‡åŒºçš„ä¸­å¿ƒè§’åº¦ï¼ˆä»0åº¦ï¼Œå³ç”»å¸ƒå³ä¾§ï¼Œé€†æ—¶é’ˆè®¡ç®—ï¼‰
            const targetSectorCenterAngle = targetOptionIndex * arcSize + arcSize / 2;
            // æˆ‘ä»¬å¸Œæœ›ç›®æ ‡æ‰‡åŒºçš„ä¸­å¿ƒå¯¹å‡†ç”»å¸ƒé¡¶éƒ¨ï¼ˆ-Math.PI / 2 æˆ– 3 * Math.PI / 2ï¼‰ã€‚
            // è½¬ç›˜éœ€è¦æ—‹è½¬çš„è§’åº¦ = -(ç›®æ ‡æ‰‡åŒºä¸­å¿ƒè§’åº¦ - ç”»å¸ƒé¡¶éƒ¨çš„è§’åº¦)
            // æ³¨æ„ï¼šç”»å¸ƒçš„æ—‹è½¬æ˜¯é¡ºæ—¶é’ˆä¸ºæ­£ï¼Œæ‰€ä»¥è¦å¯¹å‡†é¡¶éƒ¨(-PI/2)ï¼Œæ‰‡åŒºéœ€è¦é€†æ—¶é’ˆè½¬åˆ°é‚£ä¸ªä½ç½®ï¼Œæ‰€ä»¥æ˜¯è´Ÿçš„ã€‚
            // æˆ–è€…è¯´ï¼Œç”»å¸ƒéœ€è¦é¡ºæ—¶é’ˆæ—‹è½¬ (targetSectorCenterAngle - (-PI/2)) = targetSectorCenterAngle + PI/2
            // ä½†ç”±äºæˆ‘ä»¬ drawWheel(rotationAngle) ä¸­çš„ rotationAngle æ˜¯è®©ç”»å¸ƒå†…å®¹é€†æ—¶é’ˆè½¬ï¼Œæ‰€ä»¥è¿™é‡Œåº”è¯¥æ˜¯
            // -(targetSectorCenterAngle - (-Math.PI / 2)) = -targetSectorCenterAngle - Math.PI/2
            // ä¿®æ­£ï¼šæŒ‡é’ˆå‘ä¸Šæ˜¯-PI/2ã€‚å¦‚æœä¸€ä¸ªæ‰‡åŒºçš„ä¸­å¿ƒæ˜¯Aï¼Œæˆ‘ä»¬æƒ³è®©å®ƒè½¬åˆ°-PI/2ï¼Œé‚£ä¹ˆç”»å¸ƒï¼ˆå†…å®¹ï¼‰éœ€è¦è½¬åŠ¨ -(A - (-PI/2)) = -A - PI/2
            let targetRotation = -(targetSectorCenterAngle + Math.PI / 2);


            const baseRotations = 5; // è‡³å°‘æ—‹è½¬åœˆæ•°
            const randomExtraRotations = Math.random() * 5; // é¢å¤–éšæœºåœˆæ•°
            const totalCompleteRotations = (baseRotations + randomExtraRotations) * 2 * Math.PI;
            
            // æˆ‘ä»¬å¸Œæœ›æœ€ç»ˆåœåœ¨ targetRotationï¼Œä½†ä¸ºäº†åŠ¨ç”»æ•ˆæœï¼Œæˆ‘ä»¬è®©å®ƒä» currentRotationAngle è½¬èµ·
            // æ‰€ä»¥æ€»çš„æ—‹è½¬é‡æ˜¯ totalCompleteRotations + (targetRotation - (currentRotationAngle % (2*Math.PI)))
            // ä¸ºäº†ç¡®ä¿æ€»æ˜¯æ­£å‘æ—‹è½¬ä¸”è‡³å°‘è½¬å‡ åœˆï¼š
            // 1. å°† currentRotationAngle è§„èŒƒåŒ–åˆ° [0, 2PI)
            const normalizedCurrentAngle = (currentRotationAngle % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
            // 2. å°† targetRotation è§„èŒƒåŒ–åˆ° [0, 2PI) ç›¸å¯¹äºå½“å‰ä½ç½®
            let normalizedTargetAngle = (targetRotation % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);

            // è®¡ç®—ä» normalizedCurrentAngle åˆ° normalizedTargetAngle éœ€è¦çš„æœ€å°æ­£å‘æ—‹è½¬
            let diffAngle = normalizedTargetAngle - normalizedCurrentAngle;
            if (diffAngle < 0) {
                diffAngle += 2 * Math.PI; // ç¡®ä¿æ˜¯æ­£å‘æ—‹è½¬
            }

            const finalTargetRotation = currentRotationAngle + totalCompleteRotations + diffAngle;

            const duration = 4000 + Math.random() * 2000; // åŠ¨ç”»æŒç»­æ—¶é—´ 4-6 ç§’
            let startTime = null;

            decisionResultArea.style.display = 'none';
            decisionResultText.textContent = `- è½¬ç›˜è½¬åŠ¨ä¸­... -`;

            function animate(timestamp) {
                if (!startTime) startTime = timestamp;
                const elapsedTime = timestamp - startTime;
                let newAngle;

                if (elapsedTime < duration) {
                    const progress = elapsedTime / duration;
                    const easeOutProgress = 1 - Math.pow(1 - progress, 4); // easeOutQuart
                    // ä» currentRotationAngle å¼€å§‹å¢åŠ ï¼Œè€Œä¸æ˜¯ä»0
                    newAngle = currentRotationAngle + easeOutProgress * (finalTargetRotation - currentRotationAngle);
                    drawWheel(newAngle);
                    spinAnimationId = requestAnimationFrame(animate);
                } else {
                    newAngle = finalTargetRotation; // ç¡®ä¿ç²¾ç¡®åœåœ¨ç›®æ ‡ä½ç½®
                    drawWheel(newAngle);
                    currentRotationAngle = newAngle; // æ›´æ–°å½“å‰è§’åº¦ï¼Œä»¥ä¾¿ä¸‹æ¬¡æ—‹è½¬ä»æ­¤å¼€å§‹
                    
                    cancelAnimationFrame(spinAnimationId);
                    spinAnimationId = null;
                    isSpinning = false;
                    startDecisionBtn.disabled = false;

                    const resultOption = options[targetOptionIndex];
                    decisionResultText.textContent = `ğŸ‰ ç»“æœæ˜¯ï¼š ${resultOption} ğŸ‰`;
                    decisionResultArea.style.display = 'block';
                    addDecisionToHistory(resultOption, 'è½¬ç›˜');
                }
            }
            spinAnimationId = requestAnimationFrame(animate);
        }

        function renderHistory() {
            historyList.innerHTML = '';
            if (decisionHistory.length === 0) {
                const emptyMsg = document.createElement('li');
                emptyMsg.textContent = 'æš‚æ— å†å²è®°å½•';
                emptyMsg.style.textAlign = 'center';
                emptyMsg.style.color = '#777';
                historyList.appendChild(emptyMsg);
                clearHistoryBtn.style.display = 'none';
            } else {
                decisionHistory.forEach(item => {
                    const listItem = document.createElement('li');
                    const timeStr = new Date(item.timestamp).toLocaleString('zh-CN', { hour12: false });
                    listItem.textContent = `[${item.mode}] ${item.result} (${timeStr})`;
                    historyList.appendChild(listItem);
                });
                clearHistoryBtn.style.display = 'block';
            }
        }

        function addDecisionToHistory(result, mode) {
            const newHistoryItem = {
                result: result,
                mode: mode,
                timestamp: Date.now()
            };
            decisionHistory.unshift(newHistoryItem);
            if (decisionHistory.length > MAX_HISTORY_LENGTH) {
                decisionHistory.pop();
            }
            localStorage.setItem('decisionHistory', JSON.stringify(decisionHistory));
            renderHistory();
        }

        clearHistoryBtn.addEventListener('click', () => {
            if (confirm("ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å†å²è®°å½•å—ï¼Ÿ")) {
                decisionHistory = [];
                localStorage.removeItem('decisionHistory');
                renderHistory();
            }
        });


        startDecisionBtn.addEventListener('click', () => {
            if (isSpinning) return; // å¦‚æœæ­£åœ¨æ—‹è½¬ï¼Œåˆ™ä¸æ‰§è¡Œä»»ä½•æ“ä½œ

            if (options.length < MIN_OPTIONS_FOR_DECISION) {
                alert(`è¯·è‡³å°‘æ·»åŠ  ${MIN_OPTIONS_FOR_DECISION} ä¸ªé€‰é¡¹æ‰èƒ½å¼€å§‹å†³ç­–ï¼`);
                return;
            }

            let selectedModeValue = 'simple';
            decisionModes.forEach(radio => {
                if (radio.checked) {
                    selectedModeValue = radio.value;
                }
            });

            if (selectedModeValue === 'simple') {
                decisionResultArea.style.display = 'block';
                wheelArea.style.display = 'none';
                const randomIndex = Math.floor(Math.random() * options.length);
                const result = options[randomIndex];
                decisionResultText.textContent = `ç»“æœæ˜¯ï¼š ${result}`;
                addDecisionToHistory(result, 'ç®€å•');
            } else if (selectedModeValue === 'wheel') {
                decisionResultArea.style.display = 'none'; // ç‚¹å‡»æ—‹è½¬æ—¶å…ˆéšè—æ—§ç»“æœ
                wheelArea.style.display = 'block';
                if (options.length >= MIN_OPTIONS_FOR_DECISION) {
                    spinWheel();
                } else {
                    alert("è¯·å…ˆæ·»åŠ è¶³å¤Ÿé€‰é¡¹å†ä½¿ç”¨è½¬ç›˜æ¨¡å¼ï¼");
                }
            }
        });

        // åˆå§‹åŒ–
        renderOptions(); // åˆå§‹æ¸²æŸ“é€‰é¡¹ï¼ˆå¦‚æœå°†æ¥ä»localStorageåŠ è½½é€‰é¡¹ï¼‰
        renderHistory(); // åˆå§‹æ¸²æŸ“å†å²è®°å½•

        // åˆå§‹æ—¶ï¼Œå¦‚æœè½¬ç›˜æ¨¡å¼è¢«é€‰ä¸­ä¸”æœ‰è¶³å¤Ÿé€‰é¡¹ï¼Œä¹Ÿç»˜åˆ¶ä¸€ä¸‹
        if (document.querySelector('input[name="decision-mode"][value="wheel"]').checked && options.length >= MIN_OPTIONS_FOR_DECISION) {
            drawWheel();
        } else if (document.querySelector('input[name="decision-mode"][value="wheel"]').checked) {
            ctx.clearRect(0, 0, decisionWheelCanvas.width, decisionWheelCanvas.height);
            ctx.save();
            ctx.textAlign = 'center';
            ctx.fillStyle = '#777';
            ctx.font = '16px Arial';
            ctx.fillText('è¯·è‡³å°‘æ·»åŠ 2ä¸ªé€‰é¡¹æ‰èƒ½ç»˜åˆ¶è½¬ç›˜', decisionWheelCanvas.width / 2, decisionWheelCanvas.height / 2);
            ctx.restore();
        }
    </script>
</body>
</html>